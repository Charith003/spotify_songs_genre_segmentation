# -*- coding: utf-8 -*-
"""Spotify Songs’ Genre Segmentation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A5kPhmMKqg8kW7yYBm38WBS7ofooBb73

**Spotify Songs’ Genre Segmentation**
"""

# Import Libraries

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
from sklearn.metrics.pairwise import cosine_similarity

import warnings
warnings.filterwarnings('ignore')

# Load and Pre-process Data

import os
print(os.getcwd())

df = pd.read_csv('spotify_songs.csv')
df.head()

df = df.drop_duplicates()
df = df.dropna()

audio_features = [
    'danceability', 'energy', 'key', 'loudness',
    'speechiness', 'acousticness', 'liveness',
    'valence', 'tempo'
]

scaler = StandardScaler()
df[audio_features] = scaler.fit_transform(df[audio_features])

from sklearn.metrics.pairwise import cosine_similarity

def recommend_songs_extended(song_index, df, features, n=5):
    song_vector = df.loc[song_index, features].values.reshape(1, -1)

    # Compute cosine similarity
    similarities = cosine_similarity(song_vector, df[features].values)[0]

def recommend_songs_extended(song_index, df, features, n=5):
    song_vector = df.loc[song_index, features].values.reshape(1, -1)

    # Exclude the input song itself
    similar_indices = similarities.argsort()[-n-1:-1][::-1]

def recommend_songs_extended(song_index, df, features, n=5):
    song_vector = df.loc[song_index, features].values.reshape(1, -1)

    # Create recommendation table
    recommendations = df.iloc[similar_indices][
        ['track_name', 'track_artist', 'playlist_genre', 'playlist_subgenre']
    ].copy()

def recommend_songs_extended(song_index, df, features, n=5):
    song_vector = df.loc[song_index, features].values.reshape(1, -1)

# Add similarity score
    recommendations['similarity_score'] = similarities[similar_indices]

    return recommendations.sort_values(by='similarity_score', ascending=False)

def recommend_songs_extended(song_index, df, features, n=5):
    song_vector = df.loc[song_index, features].values.reshape(1, -1)

recommend_songs_extended(0, df, audio_features, n=5)

df.loc[0, ['track_name', 'track_artist']]

# Data Visualization & Correlation Matrix

# Histogram
sns.histplot(df['danceability'], kde=True)
plt.title('Distribution of Danceability')
plt.show()

# Correlation matrix
plt.figure(figsize=(10,8))
sns.heatmap(df[audio_features].corr(), annot=True, cmap='coolwarm')
plt.title('Correlation Matrix')
plt.show()

# Clustering

kmeans = KMeans(n_clusters=6, random_state=42)
df['cluster'] = kmeans.fit_predict(df[audio_features])

pca = PCA(n_components=2)
components = pca.fit_transform(df[audio_features])
df['pca1'] = components[:,0]
df['pca2'] = components[:,1]

sns.scatterplot(x='pca1', y='pca2', hue='cluster', data=df, palette='tab10')
plt.title('Clusters of Songs')
plt.show()

# Build Recommendation System

from sklearn.metrics.pairwise import cosine_similarity

def recommend_songs(song_index, df, features, n=5):
    song_vector = df.loc[song_index, features].values.reshape(1, -1)
    similarities = cosine_similarity(song_vector, df[features].values)[0]
    similar_indices = similarities.argsort()[-n-1:-1][::-1]

    return df.iloc[similar_indices][
        ['playlist_name', 'playlist_genre', 'playlist_subgenre']
    ]

recommendations = recommend_songs(0, df, audio_features)
print(recommendations)

def recommend_songs(song_index, df, features, n=5):
    """Recommend songs based on audio features similarity"""
    song_vector = df.loc[song_index, features].values.reshape(1, -1)

from sklearn.metrics.pairwise import cosine_similarity

def recommend_songs(song_index, df, features, n=5):
    song_vector = df.loc[song_index, features].values.reshape(1, -1)

    # Calculate similarity with all songs
    similarities = cosine_similarity(song_vector, df[features].values)[0]

    similar_indices = similarities.argsort()[-n-1:-1][::-1]

    return df.iloc[similar_indices][
        ['playlist_name', 'playlist_genre', 'playlist_subgenre']
    ]

from sklearn.metrics.pairwise import cosine_similarity

def recommend_songs(song_index, df, features, n=5):
    song_vector = df.loc[song_index, features].values.reshape(1, -1)

    # Get top similar songs (excluding the input song)
    similar_indices = similarities.argsort()[-n-1:-1][::-1]

def recommend_songs(song_index, df, features, n=5):
    song_vector = df.loc[song_index, features].values.reshape(1, -1)

    similarities = cosine_similarity(song_vector, df[features].values)[0]

    similar_indices = similarities.argsort()[-n-1:-1][::-1]

    # Return the recommended songs
    return df.iloc[similar_indices][['track_id', 'duration_ms']]

sample_song_index = 0
print("Original song:")
print(df.iloc[sample_song_index][['track_id', 'duration_ms']])
print("\nRecommended songs:")
print(recommend_songs(sample_song_index, df, audio_features))

# Analyze Clusters by Audio Features

plt.figure(figsize=(12,8))
cluster_features = df.groupby('cluster')[audio_features].mean()
sns.heatmap(cluster_features, cmap='viridis', annot=True)
plt.title('Audio Feature Means by Cluster')
plt.show()

# Test recommendations for different songs
for i in [0, 50, 100, 500]:
    print("\nOriginal Song:")
    print(df.loc[i, ['track_name', 'track_artist']])

    print("\nRecommended Songs:")
    print(recommend_songs_extended(i, df, audio_features, n=5))

print("Total songs in dataset:", len(df))
print("Audio features used:", audio_features)
print("Clusters created:", df['cluster'].nunique())

print("Spotify Song Recommendation System Successfully Built!")
print("Using audio features, clustering, and cosine similarity.")